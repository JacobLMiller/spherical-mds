<!DOCTYPE html>
<meta charset="utf-8">
<style>
    #sphere {
        stroke: #444;
        stroke-width: 2;
    }
    .polygons {
        stroke: #444;
    }

    .sites {
        stroke: black;
        fill: white;
    }

</style>

<svg width="960" height="600"></svg>

<script src="https://d3js.org/d3.v5.min.js"></script>
<script src="https://unpkg.com/d3-delaunay@5"></script>
<script src="https://unpkg.com/d3-geo-voronoi@1.5"></script>

<script>

var width = 400,
  height = 300,
  scale = 100,
  lastX = 0,
  lastY = 0,
  origin = {
    x: 55,
    y: -40
  };

var points = {
    type: "FeatureCollection",
    features: d3.range(3).map(function() {
        return {
            type: "Point",
            coordinates: [ 360 * Math.random(), 90 * (Math.random() - Math.random()) ]
        }
    })
}
var v = d3.geoVoronoi()(points);
console.log(v.polygons().features);
var projection = d3.geoOrthographic(),
    path = d3.geoPath().projection(projection);
var svg = d3.select("svg");

// zoom AND rotate
svg.call(d3.zoom().on('zoom', zoomed));

// code snippet from http://stackoverflow.com/questions/36614251
var λ = d3.scaleLinear()
  .domain([-width, width])
  .range([-180, 180])

var φ = d3.scaleLinear()
  .domain([-height, height])
  .range([90, -90]);


svg.append('path')
    .attr('id', 'sphere')
    .datum({ type: "Sphere" })
    .attr('d', path);
svg.append('g')
    .attr('class', 'polygons')
    .selectAll('path')
    .data(v.polygons().features)
    .enter()
    .append('path')
    .attr('d', path)
    .attr('fill', function(_,i) { return d3.schemeCategory10[i%10]; });
svg.append('g')
    .attr('class', 'sites')
    .selectAll('path')
    .data(points.features)
    .enter()
    .append('path')
    .attr('d', path);


function zoomed() {
  var transform = d3.event.transform;
  var r = {
    x: λ(transform.x),
    y: φ(transform.y)
  };
  var k = Math.sqrt(100 / projection.scale());
  if (d3.event.sourceEvent.wheelDelta) {
    projection.scale(scale * transform.k)
    transform.x = lastX;
    transform.y = lastY;
  } else {
    projection.rotate([origin.x + r.x, origin.y + r.y]);
    lastX = transform.x;
    lastY = transform.y;
  }
  updatePaths(svg);
}

function updatePaths(svg){
  svg.selectAll('path')
    .attr('d',path);

    //Remove and redraw text
    d3.selectAll('text').remove()

    /*svg.append('g')
        .attr('class', 'labels')
        .selectAll('path')
        .data(points.features)
        .enter()
        .append('text')
        .attr('d',labels)
        .style('text-anchor', 'middle')
        .attr('transform', function(d) {
			       return 'translate(' +  path.centroid(d) + ')';
		       })
           .text(function(d) {return d.geometry.label; });*/
}
// gentle animation
/*d3.interval(function(elapsed) {
    projection.rotate([ elapsed / 150, 0 ]);
    svg.selectAll('path')
        .attr('d', path);
}, 50);*/
</script>
